* GENERAL
=======================================
This directory contains a number of functions implementing models defined in
IERS Conventions (2010). The functions are available in FORTRAN from the IERS
website at http://maia.usno.navy.mil/conv2010/software.html. Note that the
software found at this website is routinely updated.

The FORTRAN subroutines are translated to C++ (standard c++11) with (as much as
possible) minor modifications.

* COMPILATION
=======================================
Compilation should be trivial using any gcc version supporting the c++11 standard
(option -std=c++11).

* PREQUISITIES
=======================================
The functions make use of a number of constants (e.g. PI). These can be defined in
each individual function or can be implemented in a seperate file (e.g. gencon.hpp).
This option is controlled at compile time, where the user can use the switch
-DUSE_EXTERNAL_CONSTS to define the constants in a seperate file. If this switch is
not used, then each function will declare its own constants.

* CLASIFICATION OF FUNCTIONS
=======================================
In general, Class 1, 2, and 3 models represent physical effects that
act on geodetic parameters while canonical models provide lower-level
representations or basic computations that are used by Class 1, 2, or
3 models.
Class 1 models are those recommended to be used a priori in the
reduction of raw space geodetic data in order to determine
geodetic parameter estimates.
Class 2 models are those that eliminate an observational
singularity and are purely conventional in nature.
Class 3 models are those that are not required as either Class 1 or 2.
Canonical models are accepted as is and cannot be classified as
a Class 1, 2, or 3 model.

* LIST OF AVAILABLE FUNCTIONS
=======================================

Subroutines for Chapter 4:
GCONV2.F : This function is not provided. It is implemented in the Chaos Software package though.

Subroutines for Chapter 5:
PMSDNUT2.F : implemented as pmsdnut2
UTLIBR.F   : implemented as utlibr
FUNDARG.F  : implemented as fundarg

Subroutines for Chapter 7:


* BUGS & TODO LIST
=======================================
FORTRAN subroutines use (a lot) the built-in function MOD(X,Y). What is the equivelent
in c/c++ ? Currently, this is translated via the modf function. Is this ok in every occasion ?
Another candidate could be remainder (http://www.cplusplus.com/reference/cmath/remainder/).
According to https://www.nsc.liu.se/~boein/f77to90/a5.html#section2 the function MOD(X,Y) 
calculates X - INT(X/Y)*Y. In addition, it can happen that in the same subroutine both
MOD and DMOD are present.
Affects: pmsdnut2,

* COMPARISSON WITH FORTRAN IMPLEMENTATION
=======================================
Run the program test.e found under the /test directory to check the results of this
implementation compared with the test cases given in (most) fortran routines. Note
that the cases may *NOT* be up to date. When executing the FORTRAN routines from IERS,
consider the following (Note 1):

FUNDARG.F : The FUNDARG.F and fundarg.cpp produce exactly the same results. Note however that,
            when running the FUNDARG.F routine, all input/output parameters MUST be provided
            in explicit double format (i.e. ending with D0 or something similar). E.g., for
            the test case provided at header, declare epoch as T = 0.07995893223819302D0
            and NOT T = 0.07995893223819302. Same is true for comparing the results (i.e.
            WRITE(*,100) 'dl  = ',DABS(2.291187512612069099D0-L) ).

PMSDNUT2.F: The PMSDNUT2.F and mpsdnut2.cpp functions, do not produce identical results. That
            is because FORTRAN seems to produce small 'garbage' when transforming elements of
            the vectors XS(25), XC(25), YS(25), YC(25). To fix this, use an explicit double
            decleration at the source code, i.e. instead of 
            DATA 
          .(  (IARG(I,J),i=1,6),     PER(J),   XS(J),  XC(J),  YS(J),  YC(J),
          .                                                          J=16,25)
          ./ 1, -1, 0, -2,  0, -1, 1.1196992,   -0.4,   0.3,   -0.3,   -0.4,
          .  1, -1, 0, -2,  0, -2, 1.1195149,   -2.3,   1.3,   -1.3,   -2.3,
            use:
          .(  (IARG(I,J),i=1,6),     PER(J),   XS(J),  XC(J),  YS(J),  YC(J),
          .                                                          J=16,25)
          ./ 1, -1, 0, -2,  0, -1, 1.1196992, -0.4D0, 0.3D0, -0.3D0, -0.4D0,
          .  1, -1, 0, -2,  0, -2, 1.1195149, -2.3D0, 1.3D0, -1.3D0, -2.3D0,
            c++ normally does not need this, but in any case the corresponding elements are
            declared in scientific notation.

[Note 1 : cpp library compiled with NO USE_EXTERNAL_CONSTS flag]

* LAST UPDATE
=======================================
DEC-2014
